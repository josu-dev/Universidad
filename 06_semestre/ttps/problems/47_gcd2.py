"""
[vjudge.net/problem/SPOJ-GCD2](https://vjudge.net/problem/SPOJ-GCD2)

Frank explained its friend Felman the algorithm of Euclides to calculate the GCD
of two numbers. Then Felman implements it algorithm

```c
int gcd(int a, int b)
{
    if (b == 0)
        return a;

    return gcd(b,a%b);
}
```

and it proposes to Frank that makes it but with a little integer and another
integer that has up to 250 digits.

Your task is to help Frank programming an efficient code for the challenge of
Felman.

Input
The first line of the input file contains a number representing the number of
lines to follow. Each line consists of two number A and B (0 <= A <= 40000 and
A <= B < 10^250).

Output
Print for each pair (A, B) in the input one integer representing the GCD of A
and B.

Example
Input
2
2 6
10 11

Output
2
1

Source limit is 1,000 Bytes.
**ENDS IN (NEW) LINE**
"""

import sys


def sieve_of(limit):
    bound = ((limit - 1) // 2) + 1
    sieve = [False] * bound
    for i in range(1, (int(limit**0.5) - 1) // 2 + 1):
        if sieve[i] is False:
            for j in range(2 * i * (i + 1), bound, 2 * i + 1):
                sieve[j] = True
    return [2] + [2 * i + 1 for i in range(1, bound) if sieve[i] is False]


def factors(n):
    out = {}
    for p in primes:
        if p > n:
            break
        c = 0
        while n % p == 0:
            c += 1
            n //= p

        out[p] = c
    return out


primes = sieve_of(40000)

l = sys.stdin.read().split()
li = 1
size = int(l[0]) * 2
r = []
while li < size:
    a = int(l[li])
    b = int(l[li + 1])
    li += 2

    if a < 2:
        r.append("%d\n" % (a or b))
        continue

    d = 1
    fb = factors(b)
    for k, v in factors(a).items():
        bc = fb.get(k, 0)
        d *= k ** (v if v < bc else bc)

    r.append("%d\n" % d)

sys.stdout.writelines(r)

# import sys


# def sieve_of(limit: int):
#     bound = ((limit - 1) // 2) + 1
#     sieve = [False] * bound
#     for i in range(1, (int(limit**0.5) - 1) // 2 + 1):
#         if sieve[i] is False:
#             for j in range(2 * i * (i + 1), bound, 2 * i + 1):
#                 sieve[j] = True
#     return [2] + [2 * i + 1 for i in range(1, bound) if sieve[i] is False]


# def factors(n: int):
#     out = {}  # type: dict[int,int] # type: ignore[reportTypeCommentUsage]
#     for p in primes:
#         if p > n:
#             break
#         c = 0
#         while n % p == 0:
#             c += 1
#             n //= p

#         out[p] = c
#     return out


# primes = sieve_of(40000)

# w = sys.stdin.read().split()
# wi = 1
# size = int(w[0]) * 2
# r = []  # type: list[str] # type: ignore[reportTypeCommentUsage]
# while wi < size:
#     a = int(w[wi])
#     b = int(w[wi + 1])
#     wi += 2

#     if a < 2:
#         r.append("%d\n" % (a or b))
#         continue

#     d = 1
#     fb = factors(b)
#     for k, v in factors(a).items():
#         bc = fb.get(k, 0)
#         d *= k ** (v if v < bc else bc)

#     r.append("%d\n" % d)

# sys.stdout.writelines(r)

# INPUT
# 14
# 2 6
# 10 11
# 0 89
# 34434 34434
# 22970 2338580699436272482278826243724053828333275266644809921911922774223245923760807068727574189759293870369363475482190811642064771571424102961884147361706021167632157936856741576031350128751225372173119556336014882601798082998289735588064343415088708775
# 26552 9439478635006120280587615377937294523145122407069695248275682493058747880106173877045202680440359303069169482236894732149177967006019164545920283281025121730625226144184934427467635198645469986842848991954786822469157082434038182327689516831030526823
# 39478 2363564694750660644841729154216080349601762595085795673285552207336626612184529393450548881327269656959174233780455717984597322982705520718927687687626409323008005703725373886130012293985297047573055174690220751484486142214057607303292222279293070481
# 6187 466956544679743164528245333817862535204330260954048071000141498230321080077210941884635428213651470096697380077715799325709848847997754449191458132189501376041181504118246697142121422962229932499453916177037848766869623535859252411036632658361710935
# 9615 1891734473428767454219952929220371360167108788100946464533981354212042741840613043648883088934568149831750228599734235361195666136483653968254773287484577436934785010592503249388900529914254665567181802466666979932428090555489764536194462524336498354
# 14503 9376889490137935164483385818501083593272783012677575021481867710078103094115303627989706734132402591273333812939184253006241203547163300362996219438371662920882746699850177474775266267004507914400510135051151420481004982459132560605935078890893369449
# 11478 930291424443032383234844417410093170393045046559686744121220014317781150086245010664684360314624916601771242852870030050646282593916135231667605671301652113821599245733461210775068433936230548687484657934701025114674418932866087030261318226949989533
# 31270 1420776258074970324384107788859292764245695420454416155069654723014922225708855878824848333428662907846131961919407797528341896047597414529002848426534751669475385358230325134140946841852828621351940138466806883542181713854573634362317202070001151400
# 34565 7323647877845412882797214000331728259189233013965340577915115533559215292431873637630322978858135541445570191565323296304704241181679381596880169630775206191313620854061473563189942269815996039700509930987328493387815025901451867013410161514852214633
# 7208 7193598568527088564920095375553775553461153547441245164679747823069805365297641110520980088242966755562800045458136393912222253755277174923871611455158175195165590649138852244314570642310159696259088155019089067149600645758757958019129622468424528037

# OUTPUT
# 2
# 1
# 89
# 34434
# 5
# 1
# 1
# 1
# 3
# 1
# 1
# 10
# 1
# 1
